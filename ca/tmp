#!/bin/bash

# https://jamielinux.com/docs/openssl-certificate-authority/ 
# https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash
# https://www.devside.net/wamp-server/generating-and-installing-wildcard-and-multi-domain-ssl-certificates

getopt --test > /dev/null
if [[ $? -ne 4 ]]; then
    echo "I’m sorry, `getopt --test` failed in this environment."
    exit 1
fi

# set -x

# options parameters
TYPE=
DIR=
CA_DIR=
COMMON_NAME=

BASENAME=
PASSWORD=
ORGANIZATION="Company Inc."
UNIT=
COUNTRY=IT
STATE=Italy
LOCALITY=
EMAIL=
CLIENT_CERT_COMMENT="OpenSSL Generated Client Certificate"
SERVER_CERT_COMMENT="OpenSSL Generated Server Certificate"

# internal parameters
PROGRAM=$0
MSG_PREFIX=">>> "
A_DNS=() # for ALT_NAMES
A_IP=()  # for ALT_NAMES

# RET contains (last) function return value (when present)
RET=


usage ()
{
	cat <<EOS
Usage: ${PROGRAM##*/} [ options ]

	Create a certificate of given type.

Main options:

	-t, --type <cert-type>
		Type of certificate (mandatory).
		cert-type = (ca-root | ca-intermediate | server | client)

	-d, --dir <path>
		Directory of the new CA certificate.
		Mandatory for ca-root and ca-intermediate cert-type. Ignored otherwise. 

	-c, --ca-dir <path>
		Directory of the existing CA certificate.
		Ignored for ca-root cert-type. Mandatory otherwise.

	-n, --cn, --common-name <name>
		Common Name (CN) of the certificate.

	-b, --basename <name>
		Basename of the created files. Example: <basename>.key.pem

Other options:

	--organization <text>   Organization (default "$ORGANIZATION")
	--unit <text>           Unit (default "$UNIT")
	--country <text>        Country (default "$COUNTRY")
	--state <text>          State (default "$STATE")
	--locality <text>       Locality (default "$LOCALITY")
	--email <text>          Email (default "$EMAIL")
	--basename <text>
	--password <text>

Examples:

	# Create Root CA
	$0 -t ca-root -d ~/ca/root

	# Create Intermediate CA 1
	$0 -t ca-intermediate -d ~/ca/ca1 -c ~/ca/root --common-name="Company Inc. CA 1"

	# Create Server certificate
	$0 -t server -c ~/ca/ca1 -n "*.domain.com" --basename=domain.com

	# Create Client certificate
	$0 -t client -c ~/ca/ca1 -n user --email=user@domain.com

EOS
}

# getopt params
OPTIONS=ht:d:c:n:b:
LONGOPTIONS=help,type:,dir:,ca:,common-name:,cn:,organization:,country:,state:,locality:unit:,email:,basename:,password:,dns:,ip:

# -temporarily store output to be able to check for errors
# -e.g. use “--options” parameter by name to activate quoting/enhanced mode
# -pass arguments only via   -- "$@"   to separate them correctly
PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTIONS --name "$0" -- "$@")
if [[ $? -ne 0 ]]; then
    # e.g. $? == 1
    #  then getopt has complained about wrong arguments to stdout
    exit 2
fi
# read getopt’s output this way to handle the quoting right:
eval set -- "$PARSED"

# now enjoy the options in order and nicely split until we see --
while true; do
    case "$1" in
        -h|--help)
			usage
            exit 0
            ;;
        -t|--type)
            TYPE="$2"
            shift 2
            ;;
        -d|--dir)
            DIR="$2"
            shift 2
            ;;
        -c|--ca)
            CA_DIR="$2"
            shift 2
            ;;
        -n|--common-name|--cn)
            COMMON_NAME="$2"
            shift 2
            ;;
        -b|--basename)
            BASENAME="$2"
            shift 2
            ;;
        --organization)
            ORGANIZATION="$2"
            shift 2
            ;;
        --country)
            COUNTRY="$2"
            shift 2
            ;;
        --state)
            STATE="$2"
            shift 2
            ;;
        --locality)
            LOCALITY="$2"
            shift 2
            ;;
        --unit)
            UNIT="$2"
            shift 2
            ;;
        --email)
            EMAIL="$2"
            shift 2
            ;;
        --password)
			PASSWORD="$2"
            shift 2
            ;;
		--dns)
			A_DNS+=("$2")
            shift 2
            ;;
		--ip)
			A_IP+=("$2")
            shift 2
            ;;
        --)
            shift
            break
            ;;
        *)
            echo "Programming error"
            exit 3
            ;;
    esac
done

# handle non-option arguments
if [[ $# -ne 0 ]]; then
    # echo "$0: A single input file is required."
	echo "$0: Invalid argument(s) -- $@."
    exit 1
fi


raise_error ()
{
	echo "$PROGRAM: $1"
	exit 1
}

raise_error_missing_option ()
{
	raise_error "missing option $1. Try -h for help."
}

print_params ()
{
	echo "TYPE: $TYPE"
	echo "DIR: $DIR"
	echo "CA_DIR: $CA_DIR"
	echo "COMMON_NAME: $COMMON_NAME"
	echo "DNS: ${A_DNS[*]}"
	echo "IP: ${A_IP[*]}"
}


print_params
